<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>學習歷程分析</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Noto+Sans+TC:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
</head>
<body>
    <header class="header">
        <div class="container">
          <div class="logo">
            <h1><a href="index.html#home">資許你安全</a></h1>
          </div>
          <nav class="main-nav" role="navigation" aria-label="主要導航">
            <ul>
                <li><a href="index.html#home">首頁</a></li>
                <li><a href="index.html#about">關於我們</a></li>
                <li><a href="index.html#services">服務</a></li>
                <li><a href="learn_status.html"  class="active" aria-current="page">學習歷程分析</a></li>
                <li><a href="/logout">登出</a></li>
            </ul>
          </nav>
        </div>
    </header>

    <section id="learning-analysis" class="learning-analysis">
        <div class="container">
            <br><br><br><br>
            <div class="chart-container">
                <h2>各情境錯誤次數</h2>
                <canvas id="errorCountChart"></canvas>
            </div>
            <div class="chart-container">
                <h2>各情境學習時間</h2>
                <canvas id="timeChart"></canvas>
            </div>
            <div class="chart-container">
                <h2>錯誤次數 vs 學習時間散佈圖</h2>
                <canvas id="scatterChart"></canvas>
            </div>
            <div class="summary-container">
                <h2>學習總結</h2>
                
                <!-- 總覽統計表格 -->
                <div class="summary-table-section">
                    <h3>學習統計總覽</h3>
                    <table class="summary-table">
                        <thead>
                            <tr>
                                <th>統計項目</th>
                                <th>數值</th>
                                <th>評級</th>
                                <th>說明</th>
                            </tr>
                        </thead>
                        <tbody id="summary-stats-table">
                            <!-- 統計資料將在這裡動態生成 -->
                        </tbody>
                    </table>
                </div>
                
                <!-- 各情境詳細表格 -->
                <div class="scenarios-table-section">
                    <h3>各情境學習詳情</h3>
                    <table class="scenarios-table">
                        <thead>
                            <tr>
                                <th>情境名稱</th>
                                <th>完成次數</th>
                                <th>最佳錯誤次數</th>
                                <th>最新錯誤次數</th>
                                <th>總學習時間</th>
                                <th>最後完成時間</th>
                                <th>狀態</th>
                            </tr>
                        </thead>
                        <tbody id="scenarios-details-table">
                            <!-- 情境詳情將在這裡動態生成 -->
                        </tbody>
                    </table>
                </div>
                
                <!-- 成就表格 -->
                <div class="achievements-table-section">
                    <h3>學習成就</h3>
                    <table class="achievements-table">
                        <thead>
                            <tr>
                                <th>成就類型</th>
                                <th>成就名稱</th>
                                <th>等級</th>
                                <th>獲得條件</th>
                            </tr>
                        </thead>
                        <tbody id="achievements-table">
                            <!-- 成就列表將在這裡動態生成 -->
                        </tbody>
                    </table>
                </div>
                
                <!-- 學習建議 -->
                <div class="recommendations-section">
                    <h3>學習建議</h3>
                    <div class="recommendation-text" id="recommendation-text">載入中...</div>
                </div>
            </div>
        </div>
    </section>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <h2>資許你安全</h2>
                    <p>沉浸式學習，資安教育</p>
                </div>
                <div class="footer-links">
                    <h3>快速導覽</h3>
                    <ul>
                        <li><a href="index.html#home">首頁</a></li>
                        <li><a href="index.html#about">關於我們</a></li>
                        <li><a href="index.html#services">服務</a></li>
                        <li><a href="learn_status.html"  class="active" aria-current="page">學習歷程分析</a></li>
                        <li><a href="/logout">登出</a></li>
                    </ul>
                </div>
                <div class="footer-links">
                    <h3>法律資訊</h3>
                    <ul>
                      <li><a href="/views/privacy.html">隱私權政策</a></li>
                      <li><a href="/views/tos.html">服務條款</a></li>
                    </ul>
                  </div>
                
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 資許你安全. 保留所有權利.</p>
            </div>
        </div>
    </footer>

    <script>
        function isTokenExpired(token) {
        if (!token) return true;
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            return Date.now() / 1000 > payload.exp;
        } catch {
            return true;
        }
        }

        const token = localStorage.getItem('token');
        if (!token || isTokenExpired(token)) {
            localStorage.removeItem('token');
            window.location.href = '/login.html';
        }

        // 取得學習歷程資料
        async function fetchLearnStatus() {
            try {
                const res = await fetch('/api/profile/learn_status', {
                    headers: {
                        'Authorization': 'Bearer ' + token
                    }
                });
                const result = await res.json();
                if (result.success) {
                    const data = result.data;
                    renderCharts(data);
                    updateSummary(data);
                } else {
                    document.getElementById('summary-text').innerText = '無法取得學習歷程資料';
                }
            } catch (e) {
                document.getElementById('summary-text').innerText = '載入學習歷程失敗';
                console.error('載入學習歷程失敗', e);
            }
        }

        // 時間格式化函數：秒 -> 時:分:秒 或 分:秒
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            }
        }

        // Context ID 對應表
        const contextIdMapping = {
            2: '會議室管理',
            4: '無線網路安全',
            6: '外來裝置風險',
            71: '密碼強度',
            72: '機密文件管理',
            73: '資料外洩風險',
            74: '惡意網站',
            75: '釣魚郵件防範'
        };

        // Context ID 格式化函數：轉換為中文名稱
        function formatContextId(contextId) {
            return contextIdMapping[contextId] || `情境${contextId}`;
        }

        // 日期格式化函數：將 MySQL DATETIME 轉換為年月日格式
        function formatDate(dateString) {
            if (!dateString) return '未知時間';
            try {
                const date = new Date(dateString);
                return date.toLocaleDateString('zh-TW', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });
            } catch (e) {
                return '無效時間';
            }
        }

        // 根據資料渲染圖表
        function renderCharts(data) {
            // context_id 代表關卡，err_count 代表錯誤次數，time_record 代表學習時間
            const contextLabels = [...new Set(data.map(row => row.context_id))];
            const formattedContextLabels = contextLabels.map(label => formatContextId(label));
            
            // 為每個 context 準備資料和完成時間
            const contextData = contextLabels.map(label => {
                const contextRows = data.filter(row => row.context_id === label);
                const totalTime = contextRows.reduce((sum, row) => sum + (row.time_record || 0), 0);
                const totalErrors = contextRows.reduce((sum, row) => sum + row.err_count, 0);
                
                // 找到最新的記錄（根據 created_at）
                const latestRecord = contextRows.reduce((latest, row) => {
                    return new Date(row.created_at) > new Date(latest.created_at) ? row : latest;
                }, contextRows[0]);
                
                // 找到最佳記錄（最少錯誤次數）
                const bestRecord = contextRows.reduce((best, row) => {
                    return row.err_count < best.err_count ? row : best;
                }, contextRows[0]);
                
                return {
                    contextId: label,
                    formattedId: formatContextId(label),
                    totalTime,
                    totalErrors,
                    completedAt: latestRecord.created_at,
                    latestErrorCount: latestRecord.err_count,  // 最新記錄的錯誤次數
                    bestErrorCount: bestRecord.err_count,      // 最佳記錄的錯誤次數
                    isPerfectLatest: latestRecord.err_count === 0,  // 最新記錄是否完美
                    isPerfectBest: bestRecord.err_count === 0       // 是否有完美記錄
                };
            });
            
            const learningTimes = contextData.map(item => item.totalTime);
            const errorRates = contextData.map(item => item.totalErrors);

            // 各關卡錯誤次數圖表
            new Chart(document.getElementById('errorCountChart'), {
                type: 'bar',
                data: {
                    labels: formattedContextLabels,
                    datasets: [{
                        label: '錯誤次數',
                        data: errorRates,
                        backgroundColor: '#f43f5e',
                        borderColor: '#b91c1c',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'bottom' },
                        tooltip: {
                            titleFont: {
                                size: 28
                            },
                            bodyFont: {
                                size: 24
                            },
                            padding: 20,
                            cornerRadius: 8,
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const contextInfo = contextData[index];
                                    return contextInfo.formattedId;
                                },
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const contextInfo = contextData[index];
                                    const completedDate = formatDate(contextInfo.completedAt);
                                    return [
                                        `錯誤次數: ${context.parsed.y}`,
                                        `完成時間: ${completedDate}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    if (Number.isInteger(value)) {
                                        return value;
                                    }
                                }
                            }
                        }
                    }
                }
            });

            // 各關卡學習時間圖表
            new Chart(document.getElementById('timeChart'), {
                type: 'bar',
                data: {
                    labels: formattedContextLabels,
                    datasets: [{
                        label: '學習時間(分:秒)',
                        data: learningTimes,
                        backgroundColor: '#3b82f6',
                        borderColor: '#1d4ed8',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'bottom' },
                        tooltip: {
                            titleFont: {
                                size: 28
                            },
                            bodyFont: {
                                size: 24
                            },
                            padding: 20,
                            cornerRadius: 8,
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const contextInfo = contextData[index];
                                    return contextInfo.formattedId;
                                },
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const contextInfo = contextData[index];
                                    const seconds = context.parsed.y;
                                    const completedDate = formatDate(contextInfo.completedAt);
                                    return [
                                        `學習時間: ${formatTime(seconds)}`,
                                        `完成時間: ${completedDate}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatTime(value);
                                }
                            }
                        }
                    }
                }
            });

            // 錯誤次數 vs 學習時間散佈圖
            const scatterData = data.map(row => ({
                x: row.err_count,
                y: row.time_record,
                context_id: row.context_id
            }));

            // 按 context_id 分組顯示不同顏色
            const contexts = [...new Set(data.map(row => row.context_id))];
            const colors = ['#000000', '#FF2D2D', '#4DFFFF', '#00DB00', '#E1E100', '#0000E3', '#D3A4FF', '#7D4848'];
            
            const scatterDatasets = contexts.map((context, index) => ({
                label: formatContextId(context),
                data: scatterData.filter(point => point.context_id === context),
                backgroundColor: colors[index % colors.length],
                borderColor: colors[index % colors.length],
                pointRadius: 8,
                pointHoverRadius: 10
            }));

            new Chart(document.getElementById('scatterChart'), {
                type: 'scatter',
                data: {
                    datasets: scatterDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { 
                            display: true, 
                            position: 'bottom' 
                        },
                        tooltip: {
                            titleFont: {
                                size: 28
                            },
                            bodyFont: {
                                size: 24
                            },
                            padding: 20,
                            cornerRadius: 8,
                            callbacks: {
                                title: function(context) {
                                    const datasetIndex = context[0].datasetIndex;
                                    const dataIndex = context[0].dataIndex;
                                    const dataset = scatterDatasets[datasetIndex];
                                    const dataPoint = dataset.data[dataIndex];
                                    const contextInfo = contextData.find(item => item.contextId === dataPoint.context_id);
                                    return contextInfo ? contextInfo.formattedId : formatContextId(dataPoint.context_id);
                                },
                                label: function(context) {
                                    const datasetIndex = context.datasetIndex;
                                    const dataIndex = context.dataIndex;
                                    const dataset = scatterDatasets[datasetIndex];
                                    const dataPoint = dataset.data[dataIndex];
                                    const contextInfo = contextData.find(item => item.contextId === dataPoint.context_id);
                                    const point = context.parsed;
                                    const timeFormatted = formatTime(point.y);
                                    const completedDate = formatDate(contextInfo ? contextInfo.completedAt : '');
                                    return [
                                        `錯誤次數: ${point.x}`,
                                        `學習時間: ${timeFormatted}`,
                                        `完成時間: ${completedDate}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '錯誤次數'
                            },
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    if (Number.isInteger(value)) {
                                        return value;
                                    }
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '學習時間'
                            },
                            ticks: {
                                callback: function(value) {
                                    return formatTime(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        // 更新學習總結
        function updateSummary(data) {
            const totalTimeSeconds = data.reduce((sum, row) => sum + (row.time_record || 0), 0);
            const totalErr = data.reduce((sum, row) => sum + row.err_count, 0);
            const averageErrorRate = data.length > 0 ? Math.round(totalErr / data.length) : 0;
            const totalTimeFormatted = formatTime(totalTimeSeconds);
            
            // 計算統計資料
            const contextLabels = [...new Set(data.map(row => row.context_id))];
            const totalScenarios = contextLabels.length;
            
            // 計算完美通關數量（錯誤次數為0的情境）
            const perfectScenarios = contextLabels.filter(contextId => {
                const contextRows = data.filter(row => row.context_id === contextId);
                const bestRecord = contextRows.reduce((best, row) => {
                    return row.err_count < best.err_count ? row : best;
                }, contextRows[0]);
                return bestRecord.err_count === 0;
            }).length;
            
            // 計算掌握度（基於錯誤次數）
            const masteryScore = totalScenarios > 0 ? Math.max(0, 100 - (averageErrorRate * 10)) : 0;
            
            // 計算效率指標（基於時間和錯誤次數的綜合評估）
            const avgTimePerScenario = totalScenarios > 0 ? totalTimeSeconds / totalScenarios : 0;
            const timeEfficiency = Math.max(0, 100 - (avgTimePerScenario / 60) * 5);
            const errorEfficiency = Math.max(0, 100 - averageErrorRate * 20);
            const overallEfficiency = (timeEfficiency + errorEfficiency) / 2;
            
            // 生成統計總覽表格
            generateSummaryStatsTable(totalScenarios, totalTimeFormatted, perfectScenarios, averageErrorRate, masteryScore, overallEfficiency);
            
            // 生成各情境詳細表格
            generateScenariosDetailsTable(data, contextLabels);
            
            // 生成成就表格
            generateAchievementsTable(data, totalScenarios, perfectScenarios, totalTimeSeconds, averageErrorRate);
            
            // 生成學習建議
            generateRecommendations(data, totalTimeFormatted, averageErrorRate, totalScenarios, perfectScenarios, masteryScore, overallEfficiency);
        }
        
        // 生成統計總覽表格
        function generateSummaryStatsTable(totalScenarios, totalTime, perfectScenarios, avgErrors, masteryScore, efficiency) {
            const statsTableBody = document.getElementById('summary-stats-table');
            
            const stats = [
                {
                    item: '完成情境數量',
                    value: `<span class="highlight-value">${totalScenarios}</span> 個`,
                    rating: getRating(totalScenarios, [8, 5, 3]),
                    description: '已完成的學習情境總數'
                },
                {
                    item: '總學習時間',
                    value: `<span class="highlight-time">${totalTime}</span>`,
                    rating: getRating(parseInt(totalTime.split(':')[0]), [60, 30, 10]),
                    description: '累計投入的學習時間'
                },
                {
                    item: '完美通關',
                    value: `<span class="highlight-value">${perfectScenarios}</span>/${totalScenarios}`,
                    rating: getRating(perfectScenarios, [5, 3, 1]),
                    description: '零錯誤完成的情境數量'
                },
                {
                    item: '平均錯誤次數',
                    value: `<span class="highlight-error ${getErrorClass(avgErrors)}">${avgErrors}</span> 次`,
                    rating: getRating(5 - avgErrors, [4, 2, 1]),
                    description: '每個情境的平均錯誤次數'
                },
                {
                    item: '整體掌握度',
                    value: `<span class="highlight-value">${Math.round(masteryScore)}</span>%`,
                    rating: getRating(masteryScore, [80, 60, 40]),
                    description: '基於錯誤次數計算的掌握程度'
                },
                {
                    item: '學習效率',
                    value: `<span class="highlight-value">${Math.round(efficiency)}</span>%`,
                    rating: getRating(efficiency, [80, 60, 40]),
                    description: '時間和準確度的綜合評估'
                }
            ];
            
            statsTableBody.innerHTML = stats.map(stat => `
                <tr>
                    <td><strong>${stat.item}</strong></td>
                    <td>${stat.value}</td>
                    <td><span class="${stat.rating.class}">${stat.rating.text}</span></td>
                    <td>${stat.description}</td>
                </tr>
            `).join('');
        }
        
        // 生成各情境詳細表格
        function generateScenariosDetailsTable(data, contextLabels) {
            const scenariosTableBody = document.getElementById('scenarios-details-table');
            
            const scenarioDetails = contextLabels.map(contextId => {
                const contextRows = data.filter(row => row.context_id === contextId);
                const totalTime = contextRows.reduce((sum, row) => sum + (row.time_record || 0), 0);
                const completionCount = contextRows.length;
                
                const bestRecord = contextRows.reduce((best, row) => {
                    return row.err_count < best.err_count ? row : best;
                }, contextRows[0]);
                
                const latestRecord = contextRows.reduce((latest, row) => {
                    return new Date(row.created_at) > new Date(latest.created_at) ? row : latest;
                }, contextRows[0]);
                
                return {
                    name: formatContextId(contextId),
                    completionCount,
                    bestErrors: bestRecord.err_count,
                    latestErrors: latestRecord.err_count,
                    totalTime: formatTime(totalTime),
                    lastCompleted: formatDate(latestRecord.created_at),
                    status: getScenarioStatus(bestRecord.err_count, latestRecord.err_count)
                };
            });
            
            scenariosTableBody.innerHTML = scenarioDetails.map(scenario => `
                <tr>
                    <td><strong>${scenario.name}</strong></td>
                    <td><span class="highlight-value">${scenario.completionCount}</span> 次</td>
                    <td><span class="highlight-error ${getErrorClass(scenario.bestErrors)}">${scenario.bestErrors}</span> 次</td>
                    <td><span class="highlight-error ${getErrorClass(scenario.latestErrors)}">${scenario.latestErrors}</span> 次</td>
                    <td><span class="highlight-time">${scenario.totalTime}</span></td>
                    <td>${scenario.lastCompleted}</td>
                    <td><span class="${scenario.status.class}">${scenario.status.text}</span></td>
                </tr>
            `).join('');
        }
        
        // 生成成就表格
        function generateAchievementsTable(data, totalScenarios, perfectScenarios, totalTimeSeconds, avgErrors) {
            const achievementsTableBody = document.getElementById('achievements-table');
            const achievements = [];
            
            // 完成情境成就
            if (totalScenarios >= 8) {
                achievements.push({
                    type: '情境完成',
                    name: '資安專家',
                    level: 'gold',
                    condition: '完成所有 8 個學習情境'
                });
            } else if (totalScenarios >= 5) {
                achievements.push({
                    type: '情境完成',
                    name: '情境探索者',
                    level: 'silver',
                    condition: `完成 ${totalScenarios} 個學習情境`
                });
            } else if (totalScenarios >= 3) {
                achievements.push({
                    type: '情境完成',
                    name: '學習新手',
                    level: 'bronze',
                    condition: `完成 ${totalScenarios} 個學習情境`
                });
            }
            
            // 完美通關成就
            if (perfectScenarios >= 5) {
                achievements.push({
                    type: '完美通關',
                    name: '完美主義者',
                    level: 'gold',
                    condition: `${perfectScenarios} 次完美通關`
                });
            } else if (perfectScenarios >= 3) {
                achievements.push({
                    type: '完美通關',
                    name: '精準射手',
                    level: 'silver',
                    condition: `${perfectScenarios} 次完美通關`
                });
            } else if (perfectScenarios >= 1) {
                achievements.push({
                    type: '完美通關',
                    name: '初露鋒芒',
                    level: 'bronze',
                    condition: `${perfectScenarios} 次完美通關`
                });
            }
            
            // 學習時間成就
            const totalMinutes = Math.floor(totalTimeSeconds / 60);
            if (totalMinutes >= 60) {
                achievements.push({
                    type: '學習時間',
                    name: '學習馬拉松',
                    level: 'gold',
                    condition: '累計學習超過 1 小時'
                });
            } else if (totalMinutes >= 30) {
                achievements.push({
                    type: '學習時間',
                    name: '專注學習者',
                    level: 'silver',
                    condition: '累計學習超過 30 分鐘'
                });
            } else if (totalMinutes >= 10) {
                achievements.push({
                    type: '學習時間',
                    name: '時間投資者',
                    level: 'bronze',
                    condition: '累計學習超過 10 分鐘'
                });
            }
            
            // 錯誤率成就
            if (avgErrors <= 1) {
                achievements.push({
                    type: '準確度',
                    name: '神射手',
                    level: 'gold',
                    condition: '平均錯誤次數 ≤ 1'
                });
            } else if (avgErrors <= 2) {
                achievements.push({
                    type: '準確度',
                    name: '準確射手',
                    level: 'silver',
                    condition: '平均錯誤次數 ≤ 2'
                });
            }
            
            if (achievements.length === 0) {
                achievementsTableBody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--gray-500); font-style: italic;">繼續學習以解鎖更多成就！</td></tr>';
            } else {
                achievementsTableBody.innerHTML = achievements.map(achievement => `
                    <tr>
                        <td><strong>${achievement.type}</strong></td>
                        <td>${achievement.name}</td>
                        <td><span class="achievement-${achievement.level}">${getLevelIcon(achievement.level)} ${getLevelText(achievement.level)}</span></td>
                        <td>${achievement.condition}</td>
                    </tr>
                `).join('');
            }
        }
        
        // 生成學習建議
        function generateRecommendations(data, totalTime, avgErrors, totalScenarios, perfectScenarios, masteryScore, efficiency) {
            const recommendationText = document.getElementById('recommendation-text');
            
            let recommendations = `<strong>📊 學習概況：</strong><br>`;
            recommendations += `你總共完成了 <span class="highlight-value">${totalScenarios}</span> 個資安情境的學習，累計學習時間為 <span class="highlight-time">${totalTime}</span>。<br><br>`;
            
            recommendations += `<strong>🎯 表現分析：</strong><br>`;
            if (perfectScenarios > 0) {
                recommendations += `🎉 恭喜！你在 <span class="highlight-value">${perfectScenarios}</span> 個情境中達到了完美通關（零錯誤）！<br>`;
            }
            
            recommendations += `平均每個情境的錯誤次數為 <span class="highlight-error ${getErrorClass(avgErrors)}">${avgErrors}</span> 次。<br><br>`;
            
            recommendations += `<strong>💡 學習建議：</strong><br>`;
            if (masteryScore >= 80) {
                recommendations += `🌟 <strong>優秀表現：</strong>你的掌握度達到了 ${Math.round(masteryScore)}%，表現非常出色！建議挑戰更高難度的資安情境或深入學習相關理論知識。`;
            } else if (masteryScore >= 60) {
                recommendations += `📈 <strong>良好進步：</strong>你的掌握度為 ${Math.round(masteryScore)}%，已經有了不錯的基礎。建議重點複習錯誤較多的情境，並加強相關概念的理解。`;
            } else {
                recommendations += `💪 <strong>持續努力：</strong>你的掌握度為 ${Math.round(masteryScore)}%，還有很大的提升空間。建議重複練習基礎情境，仔細閱讀相關資安知識，並尋求額外的學習資源。`;
            }
            
            recommendationText.innerHTML = recommendations;
        }
        
        // 輔助函數
        function getRating(value, thresholds) {
            if (value >= thresholds[0]) {
                return { class: 'rating-excellent', text: '優秀' };
            } else if (value >= thresholds[1]) {
                return { class: 'rating-good', text: '良好' };
            } else if (value >= thresholds[2]) {
                return { class: 'rating-average', text: '一般' };
            } else {
                return { class: 'rating-poor', text: '待改進' };
            }
        }
        
        function getErrorClass(errors) {
            if (errors <= 1) return 'low';
            if (errors <= 3) return 'medium';
            return 'high';
        }
        
        function getScenarioStatus(bestErrors, latestErrors) {
            if (bestErrors === 0) {
                return { class: 'status-perfect', text: '完美掌握' };
            } else if (latestErrors <= bestErrors) {
                return { class: 'status-good', text: '持續進步' };
            } else if (latestErrors <= 2) {
                return { class: 'status-average', text: '表現良好' };
            } else {
                return { class: 'status-needs-improvement', text: '需要加強' };
            }
        }
        
        function getLevelIcon(level) {
            switch(level) {
                case 'gold': return '🏆';
                case 'silver': return '🥈';
                case 'bronze': return '🥉';
                default: return '🏅';
            }
        }
        
        function getLevelText(level) {
            switch(level) {
                case 'gold': return '金級';
                case 'silver': return '銀級';
                case 'bronze': return '銅級';
                default: return '普通';
            }
        }

        // 初始化
        fetchLearnStatus();
    </script>
</body>
</html>