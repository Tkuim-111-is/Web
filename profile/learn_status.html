<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>學習歷程分析</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Noto+Sans+TC:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
</head>
<body>
    <header class="header">
        <div class="container">
          <div class="logo">
            <h1><a href="index.html#home">資許你安全</a></h1>
          </div>
          <nav class="main-nav" role="navigation" aria-label="主要導航">
            <ul>
                <li><a href="index.html#home">首頁</a></li>
                <li><a href="index.html#about">關於我們</a></li>
                <li><a href="index.html#services">服務</a></li>
                <li><a href="learn_status.html"  class="active" aria-current="page">學習歷程分析</a></li>
                <li><a href="/logout">登出</a></li>
            </ul>
          </nav>
        </div>
    </header>

    <section id="learning-analysis" class="learning-analysis">
        <div class="container">
            <br><br><br><br>
            <div class="chart-container">
                <h2>各情境錯誤次數</h2>
                <canvas id="errorCountChart"></canvas>
            </div>
            <div class="chart-container">
                <h2>各情境學習時間</h2>
                <canvas id="timeChart"></canvas>
            </div>
            <div class="chart-container">
                <h2>錯誤次數 vs 學習時間散佈圖</h2>
                <canvas id="scatterChart"></canvas>
            </div>
            <div class="summary-container">
                <h2>學習總結</h2>
                <p id="summary-text">載入中...</p>
            </div>
        </div>
    </section>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <h2>資許你安全</h2>
                    <p>沉浸式學習，資安教育</p>
                </div>
                <div class="footer-links">
                    <h3>快速導覽</h3>
                    <ul>
                        <li><a href="index.html#home">首頁</a></li>
                        <li><a href="index.html#about">關於我們</a></li>
                        <li><a href="index.html#services">服務</a></li>
                        <li><a href="learn_status.html"  class="active" aria-current="page">學習歷程分析</a></li>
                        <li><a href="/logout">登出</a></li>
                    </ul>
                </div>
                <div class="footer-links">
                    <h3>法律資訊</h3>
                    <ul>
                      <li><a href="/views/privacy.html">隱私權政策</a></li>
                      <li><a href="/views/tos.html">服務條款</a></li>
                    </ul>
                  </div>
                <div class="footer-social">
                    <h3>關注我們</h3>
                    <div class="social-icons">
                        <a href="https://github.com/Tkuim-111-is/Surecurity" class="social-icon"><img src="/static/images/github-mark-white.svg" alt="Github"></a>
                    </div>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 淡江資管. 保留所有權利.</p>
            </div>
        </div>
    </footer>

    <script>
        function isTokenExpired(token) {
        if (!token) return true;
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            return Date.now() / 1000 > payload.exp;
        } catch {
            return true;
        }
        }

        const token = localStorage.getItem('token');
        if (!token || isTokenExpired(token)) {
            localStorage.removeItem('token');
            window.location.href = '/login.html';
        }

        // 取得學習歷程資料
        async function fetchLearnStatus() {
            try {
                const res = await fetch('/api/profile/learn_status', {
                    headers: {
                        'Authorization': 'Bearer ' + token
                    }
                });
                const result = await res.json();
                if (result.success) {
                    const data = result.data;
                    renderCharts(data);
                    updateSummary(data);
                } else {
                    document.getElementById('summary-text').innerText = '無法取得學習歷程資料';
                }
            } catch (e) {
                document.getElementById('summary-text').innerText = '載入學習歷程失敗';
                console.error('載入學習歷程失敗', e);
            }
        }

        // 時間格式化函數：秒 -> 分:秒
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // Context ID 對應表
        const contextIdMapping = {
            2: '會議室管理',
            4: '無線網路安全',
            6: '外來裝置風險',
            71: '密碼強度',
            72: '機密文件管理',
            73: '資料外洩風險',
            74: '惡意網站',
            75: '釣魚郵件防範'
        };

        // Context ID 格式化函數：轉換為中文名稱
        function formatContextId(contextId) {
            return contextIdMapping[contextId] || `情境${contextId}`;
        }

        // 日期格式化函數：將 MySQL DATETIME 轉換為年月日格式
        function formatDate(dateString) {
            if (!dateString) return '未知時間';
            try {
                const date = new Date(dateString);
                return date.toLocaleDateString('zh-TW', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });
            } catch (e) {
                return '無效時間';
            }
        }

        // 根據資料渲染圖表
        function renderCharts(data) {
            // context_id 代表關卡，err_count 代表錯誤次數，time_record 代表學習時間
            const contextLabels = [...new Set(data.map(row => row.context_id))];
            const formattedContextLabels = contextLabels.map(label => formatContextId(label));
            
            // 為每個 context 準備資料和完成時間
            const contextData = contextLabels.map(label => {
                const contextRows = data.filter(row => row.context_id === label);
                const totalTime = contextRows.reduce((sum, row) => sum + (row.time_record || 0), 0);
                const totalErrors = contextRows.reduce((sum, row) => sum + row.err_count, 0);
                
                // 找到最新的記錄（根據 created_at）
                const latestRecord = contextRows.reduce((latest, row) => {
                    return new Date(row.created_at) > new Date(latest.created_at) ? row : latest;
                }, contextRows[0]);
                
                // 找到最佳記錄（最少錯誤次數）
                const bestRecord = contextRows.reduce((best, row) => {
                    return row.err_count < best.err_count ? row : best;
                }, contextRows[0]);
                
                return {
                    contextId: label,
                    formattedId: formatContextId(label),
                    totalTime,
                    totalErrors,
                    completedAt: latestRecord.created_at,
                    latestErrorCount: latestRecord.err_count,  // 最新記錄的錯誤次數
                    bestErrorCount: bestRecord.err_count,      // 最佳記錄的錯誤次數
                    isPerfectLatest: latestRecord.err_count === 0,  // 最新記錄是否完美
                    isPerfectBest: bestRecord.err_count === 0       // 是否有完美記錄
                };
            });
            
            const learningTimes = contextData.map(item => item.totalTime);
            const errorRates = contextData.map(item => item.totalErrors);

            // 為錯誤次數圖表準備顏色 - 根據最新記錄判定完美表現
            const errorColors = contextData.map(item => 
                item.isPerfectLatest ? '#ffd700' : '#f43f5e'  // 金色代表最新記錄完美表現
            );
            const errorBorderColors = contextData.map(item => 
                item.isPerfectLatest ? '#ffb000' : '#b91c1c'
            );

            // 各關卡錯誤次數圖表
            new Chart(document.getElementById('errorCountChart'), {
                type: 'bar',
                data: {
                    labels: formattedContextLabels,
                    datasets: [{
                        label: '最新記錄錯誤次數',
                        data: contextData.map(item => item.latestErrorCount),
                        backgroundColor: errorColors,
                        borderColor: errorBorderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const contextInfo = contextData[index];
                                    return contextInfo.formattedId;
                                },
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const contextInfo = contextData[index];
                                    const completedDate = formatDate(contextInfo.completedAt);
                                    const latestErrorCount = context.parsed.y;
                                    const labels = [
                                        `最新記錄錯誤次數: ${latestErrorCount}`,
                                        `歷史最佳錯誤次數: ${contextInfo.bestErrorCount}`,
                                        `總錯誤次數: ${contextInfo.totalErrors}`,
                                        `最新完成時間: ${completedDate}`
                                    ];
                                    if (latestErrorCount === 0) {
                                        labels.push('🏆 最新記錄完美表現！');
                                    } else if (contextInfo.bestErrorCount === 0) {
                                        labels.push('⭐ 曾有完美表現記錄');
                                    }
                                    return labels;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });

            // 各關卡學習時間圖表
            new Chart(document.getElementById('timeChart'), {
                type: 'bar',
                data: {
                    labels: formattedContextLabels,
                    datasets: [{
                        label: '學習時間 (秒)',
                        data: learningTimes,
                        backgroundColor: '#3b82f6',
                        borderColor: '#1d4ed8',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const contextInfo = contextData[index];
                                    return contextInfo.formattedId;
                                },
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const contextInfo = contextData[index];
                                    const seconds = context.parsed.y;
                                    const completedDate = formatDate(contextInfo.completedAt);
                                    return [
                                        `學習時間: ${formatTime(seconds)} (${seconds}秒)`,
                                        `完成時間: ${completedDate}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatTime(value);
                                }
                            }
                        }
                    }
                }
            });

            // 錯誤次數 vs 學習時間散佈圖
            const scatterData = data.map(row => ({
                x: row.err_count,
                y: row.time_record,
                context_id: row.context_id
            }));

            // 按 context_id 分組顯示不同顏色
            const contexts = [...new Set(data.map(row => row.context_id))];
            const colors = ['#f43f5e', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ef4444', '#06b6d4', '#84cc16'];
            
            const scatterDatasets = contexts.map((context, index) => {
                const contextPoints = scatterData.filter(point => point.context_id === context);
                const contextInfo = contextData.find(item => item.contextId === context);
                const isPerfectLatest = contextInfo ? contextInfo.isPerfectLatest : false;
                
                return {
                    label: formatContextId(context) + (isPerfectLatest ? ' 🏆' : ''),
                    data: contextPoints,
                    backgroundColor: isPerfectLatest ? '#ffd700' : colors[index % colors.length],
                    borderColor: isPerfectLatest ? '#ffb000' : colors[index % colors.length],
                    pointRadius: isPerfectLatest ? 10 : 8,
                    pointHoverRadius: isPerfectLatest ? 12 : 10
                };
            });

            new Chart(document.getElementById('scatterChart'), {
                type: 'scatter',
                data: {
                    datasets: scatterDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { 
                            display: true, 
                            position: 'bottom' 
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const datasetIndex = context[0].datasetIndex;
                                    const dataIndex = context[0].dataIndex;
                                    const dataset = scatterDatasets[datasetIndex];
                                    const dataPoint = dataset.data[dataIndex];
                                    const contextInfo = contextData.find(item => item.contextId === dataPoint.context_id);
                                    return contextInfo ? contextInfo.formattedId : formatContextId(dataPoint.context_id);
                                },
                                label: function(context) {
                                    const datasetIndex = context.datasetIndex;
                                    const dataIndex = context.dataIndex;
                                    const dataset = scatterDatasets[datasetIndex];
                                    const dataPoint = dataset.data[dataIndex];
                                    const contextInfo = contextData.find(item => item.contextId === dataPoint.context_id);
                                    const point = context.parsed;
                                    const timeFormatted = formatTime(point.y);
                                    const completedDate = formatDate(contextInfo ? contextInfo.completedAt : '');
                                    const labels = [
                                        `錯誤次數: ${point.x}`,
                                        `學習時間: ${timeFormatted} (${point.y}秒)`,
                                        `完成時間: ${completedDate}`
                                    ];
                                    if (point.x === 0) {
                                        labels.push('🏆 完美表現！');
                                    }
                                    return labels;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '錯誤次數 (err_count)'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '學習時間 (time_record)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return formatTime(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        // 更新學習總結
        function updateSummary(data) {
            const totalTimeSeconds = data.reduce((sum, row) => sum + (row.time_record || 0), 0);
            const totalErr = data.reduce((sum, row) => sum + row.err_count, 0);
            const averageErrorRate = data.length > 0 ? (totalErr / data.length).toFixed(2) : 0;
            const totalTimeFormatted = formatTime(totalTimeSeconds);
            
            // 計算完美表現的情境數量（基於最新記錄）
            const contextLabels = [...new Set(data.map(row => row.context_id))];
            const contextSummary = contextLabels.map(contextId => {
                const contextRows = data.filter(row => row.context_id === contextId);
                const latestRecord = contextRows.reduce((latest, row) => {
                    return new Date(row.created_at) > new Date(latest.created_at) ? row : latest;
                }, contextRows[0]);
                const bestRecord = contextRows.reduce((best, row) => {
                    return row.err_count < best.err_count ? row : best;
                }, contextRows[0]);
                
                return {
                    contextId,
                    latestErrorCount: latestRecord.err_count,
                    bestErrorCount: bestRecord.err_count,
                    isPerfectLatest: latestRecord.err_count === 0,
                    isPerfectBest: bestRecord.err_count === 0
                };
            });
            
            const perfectLatestContexts = contextSummary.filter(item => item.isPerfectLatest);
            const perfectBestContexts = contextSummary.filter(item => item.isPerfectBest && !item.isPerfectLatest);
            
            let summaryText = `你總共花了 ${totalTimeFormatted} 學習，平均錯誤次數為 ${averageErrorRate}。`;
            
            if (perfectLatestContexts.length > 0) {
                const perfectLatestNames = perfectLatestContexts.map(item => formatContextId(item.contextId)).join('、');
                summaryText += `\n\n🏆 恭喜！你在以下 ${perfectLatestContexts.length} 個情境中最新記錄達到完美表現（零錯誤）：\n${perfectLatestNames}`;
            }
            
            if (perfectBestContexts.length > 0) {
                const perfectBestNames = perfectBestContexts.map(item => formatContextId(item.contextId)).join('、');
                summaryText += `\n\n⭐ 你在以下 ${perfectBestContexts.length} 個情境中曾經達到完美表現：\n${perfectBestNames}`;
            }
            
            document.getElementById('summary-text').innerText = summaryText;
        }

        // 初始化
        fetchLearnStatus();
    </script>
</body>
</html>