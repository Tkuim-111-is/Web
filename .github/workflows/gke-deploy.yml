name: æ§‹å»ºä¸¦éƒ¨ç½²åˆ° GKE

on:
  push:
    branches: [develop , "Set/GKE"]
    tags: ["v*.*.*"]
  pull_request:
    branches: ["develop"]

permissions:
  contents: read
  packages: write
  id-token: write

env:
  PROJECT_ID: ${{ secrets.GKE_PROJECT }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER }}
  GKE_ZONE: ${{ secrets.GKE_ZONE }}
  REGISTRY_URL: asia-east1-docker.pkg.dev 
  GCP_PROJECT_NUMBER: '1061852642455' 
  REPOSITORY_NAME: deno-web-app
  IMAGE_NAME: deno-web-app
  DEPLOYMENT_NAME: deno-web-app

jobs:
  build:
    name: æ§‹å»ºä¸¦æ¨é€ Docker æ˜ åƒ
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.image-tag.outputs.tag }}

    steps:
      - name: è¨­ç½®å€‰åº«è®Šæ•¸
        run: |
          echo "è¨­ç½®å€‰åº«åç¨±ç‚º: ${{ env.REPOSITORY_NAME }}"

      - name: æª¢å‡ºä»£ç¢¼
        uses: actions/checkout@v4

      - name: è¨­ç½® Helm
        uses: Azure/setup-helm@v4.3.1

      - name: è¨­ç½® Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - id: 'auth'
        name: 'ä½¿ç”¨ WIF é©—è­‰åˆ° GCP'
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: 'projects/${{ env.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/github-actions-pool/providers/github-provider'
          service_account: 'github-actions-sa@${{ env.PROJECT_ID }}.iam.gserviceaccount.com'

      - name: ç™»å…¥ Artifact Registry
        run: |-
          gcloud auth print-access-token | docker login -u oauth2accesstoken --password-stdin https://${{ env.REGISTRY_URL }}

      - name: è¨­ç½®æ˜ åƒæ¨™ç±¤
        id: image-tag
        run: |
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            TAG_NAME=$(echo "${{ github.ref_name }}" | tr '[:upper:]' '[:lower:]')
            echo "tag=${{ env.REGISTRY_URL }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/${{ env.IMAGE_NAME }}:${TAG_NAME}" >> $GITHUB_OUTPUT
          else
            SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
            BRANCH=$(echo ${{ github.ref_name }} | sed 's/\//-/g' | tr '[:upper:]' '[:lower:]')
            echo "tag=${{ env.REGISTRY_URL }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/${{ env.IMAGE_NAME }}:${BRANCH}-${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi
          echo "ä½¿ç”¨çš„æ˜ åƒæ¨™ç±¤: $(cat $GITHUB_OUTPUT | grep tag= | cut -d= -f2)"

      - name: æå– Docker å…ƒæ•¸æ“š
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_URL }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}},event=tag
            type=semver,pattern={{major}}.{{minor}},event=tag
            type=sha,format=short

      - name: æ§‹å»ºä¸¦æ¨é€ Docker æ˜ åƒ
        uses: docker/build-push-action@v5
        with:
          context: .
          push: ${{ github.event_name!= 'pull_request' }}
          tags: ${{ steps.image-tag.outputs.tag }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: éƒ¨ç½²åˆ° GKE å¢é›†
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name!= 'pull_request'

    steps:
      - name: æª¢å‡ºä»£ç¢¼
        uses: actions/checkout@v4

      - name: è¨­ç½® Helm
        uses: Azure/setup-helm@v4.3.1

      - id: 'auth'
        name: 'ä½¿ç”¨ WIF é©—è­‰åˆ° GCP'
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: 'projects/${{ env.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/github-actions-pool/providers/github-provider'
          service_account: 'github-actions-sa@${{ env.PROJECT_ID }}.iam.gserviceaccount.com'

      - name: è¨­ç½® GKE èªè­‰
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}
          project_id: ${{ env.PROJECT_ID }}

      - name: å‰µå»ºå‘½åç©ºé–“
        run: |
          kubectl create namespace ${{ env.DEPLOYMENT_NAME }} --dry-run=client -o yaml | kubectl apply -f -

      - name: å‰µå»º Docker Registry Secret
        run: |
          kubectl create secret docker-registry ghcr-auth \
            --namespace ${{ env.DEPLOYMENT_NAME }} \
            --docker-server=${{ env.REGISTRY_URL }} \
            --docker-username=oauth2accesstoken \
            --docker-password=$(gcloud auth print-access-token) \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: ç¢ºèªä¸¦è¨­ç½® Secret Manager
        run: |
          echo "ğŸ” æª¢æŸ¥ GKE å¢é›†çš„ Secret Manager å¤–æ›ç¨‹å¼ç‹€æ…‹..."
          
          # æª¢æŸ¥ Secret Manager å¤–æ›ç¨‹å¼æ˜¯å¦å·²å•Ÿç”¨
          SECRET_MANAGER_ENABLED=$(gcloud container clusters describe ${{ env.GKE_CLUSTER }} \
            --location=${{ env.GKE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --format="value(addonsConfig.secretManagerConfig.enabled)" || echo "false")
          
          if [ "$SECRET_MANAGER_ENABLED" = "true" ] || [ "$SECRET_MANAGER_ENABLED" = "True" ]; then
            echo "âœ… Secret Manager å¤–æ›ç¨‹å¼å·²å•Ÿç”¨"
          else
            echo "âŒ Secret Manager å¤–æ›ç¨‹å¼æœªå•Ÿç”¨ï¼Œæ­£åœ¨å•Ÿç”¨..."
            gcloud container clusters update ${{ env.GKE_CLUSTER }} \
              --location=${{ env.GKE_ZONE }} \
              --project=${{ env.PROJECT_ID }} \
              --enable-secret-manager
            echo "âœ… Secret Manager å¤–æ›ç¨‹å¼å·²å•Ÿç”¨"
          fi
          
          # é©—è­‰ä¸¦å‰µå»ºå¿…è¦çš„ secrets
          echo "ğŸ” æª¢æŸ¥ä¸¦å‰µå»º Secret Manager ä¸­çš„ secrets..."
          SECRETS_TO_CHECK=("JWT_SECRET" "DB_PASS" "DB_USER")
          
          # ç”Ÿæˆéš¨æ©Ÿå€¼çš„å‡½æ•¸
          generate_random_secret() {
            openssl rand -base64 32 | tr -d "=+/" | cut -c1-32
          }
          
          for secret_name in "${SECRETS_TO_CHECK[@]}"; do
            if gcloud secrets describe "$secret_name" --project=${{ env.PROJECT_ID }} >/dev/null 2>&1; then
              echo "âœ… Secret '$secret_name' å·²å­˜åœ¨æ–¼ Secret Manager"
            else
              echo "ğŸ†• Secret '$secret_name' ä¸å­˜åœ¨ï¼Œæ­£åœ¨å‰µå»º..."
              
              # å‰µå»º secret
              gcloud secrets create "$secret_name" \
                --project=${{ env.PROJECT_ID }} \
                --replication-policy="automatic"
              
              # ç”Ÿæˆä¸¦è¨­ç½®å€¼
              SECRET_VALUE=""
              case "$secret_name" in
                "JWT_SECRET")
                  SECRET_VALUE=$(generate_random_secret)
                  ;;
                "DB_USER")
                  SECRET_VALUE="deno_user"
                  ;;
                "DB_PASS")
                  SECRET_VALUE=$(generate_random_secret)
                  ;;
              esac
              
              echo "$SECRET_VALUE" | gcloud secrets versions add "$secret_name" \
                --project=${{ env.PROJECT_ID }} \
                --data-file=-
              
              echo "âœ… Secret '$secret_name' å·²å‰µå»ºä¸¦è¨­ç½®å€¼"
            fi
          done
          
          echo "ğŸ‰ æ‰€æœ‰å¿…è¦çš„ secrets éƒ½å·²å°±ç·’ï¼"

      - name: è¨­å®š Workload Identity æ¬Šé™
        run: |
          echo "ğŸ” è¨­å®š Workload Identity æ¬Šé™..."
          
          # ç‚ºæ¯å€‹ secret è¨­å®š IAM æ¬Šé™
          KSA_NAME="${{ env.DEPLOYMENT_NAME }}"
          NAMESPACE="${{ env.DEPLOYMENT_NAME }}"
          
          SECRETS_TO_BIND=("JWT_SECRET" "DB_PASS" "DB_USER")
          
          for secret_name in "${SECRETS_TO_BIND[@]}"; do
            echo "è¨­å®š Secret '$secret_name' çš„ IAM æ¬Šé™..."
            gcloud secrets add-iam-policy-binding "$secret_name" \
              --role=roles/secretmanager.secretAccessor \
              --member="principal://iam.googleapis.com/projects/${{ env.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/${{ env.PROJECT_ID }}.svc.id.goog/subject/ns/${NAMESPACE}/sa/${KSA_NAME}" \
              --project=${{ env.PROJECT_ID }}
          done
          
          echo "âœ… Workload Identity æ¬Šé™è¨­å®šå®Œæˆ"

      - name: å¼·åˆ¶æ¸…ç† Helm ç‹€æ…‹
        run: |
          echo "æª¢æŸ¥ä¸¦å¼·åˆ¶æ¸…ç† Helm release ç‹€æ…‹..."
          
          # æª¢æŸ¥ç¾æœ‰çš„ release
          if helm list -n ${{ env.DEPLOYMENT_NAME }} -a | grep ${{ env.DEPLOYMENT_NAME }}; then
            echo "ç™¼ç¾ç¾æœ‰çš„ releaseï¼Œæª¢æŸ¥ç‹€æ…‹..."
            helm status ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }} || echo "ç„¡æ³•ç²å–ç‹€æ…‹"
            
            # å¼·åˆ¶åˆªé™¤å¡ä½çš„ release
            echo "ğŸ—‘ï¸  å¼·åˆ¶åˆªé™¤ç¾æœ‰çš„ release..."
            helm uninstall ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }} --timeout=120s || echo "å¸è¼‰å¤±æ•—ï¼Œç¹¼çºŒé€²è¡Œ"
            
            # æ¸…ç†ç›¸é—œ Kubernetes è³‡æº
            echo "ğŸ§¹ æ¸…ç†ç›¸é—œ Kubernetes è³‡æº..."
            kubectl delete deployment ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }} --ignore-not-found=true
            kubectl delete service ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }} --ignore-not-found=true
            kubectl delete ingress ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }} --ignore-not-found=true
            kubectl delete configmap ${{ env.DEPLOYMENT_NAME }}-config -n ${{ env.DEPLOYMENT_NAME }} --ignore-not-found=true
            
            # ç­‰å¾…è³‡æºæ¸…ç†å®Œæˆ
            echo "â³ ç­‰å¾…è³‡æºæ¸…ç†å®Œæˆ..."
            sleep 10
          else
            echo "âœ… æ²’æœ‰ç¾æœ‰çš„ release"
          fi

      - name: æº–å‚™æ˜ åƒæ¨™ç±¤
        id: prepare-tag
        run: |
          echo "æª¢æŸ¥æ˜ åƒæ¨™ç±¤..."
          
          # æª¢æŸ¥æ˜¯å¦æœ‰ build job çš„è¼¸å‡º
          if [[ -n "${{ needs.build.outputs.image_tag }}" ]]; then
            IMAGE_TAG=$(echo "${{ needs.build.outputs.image_tag }}" | cut -d: -f2-)
            echo "ä½¿ç”¨ build job çš„æ˜ åƒæ¨™ç±¤: $IMAGE_TAG"
          else
            # ç”Ÿæˆé»˜èªæ¨™ç±¤
            SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
            BRANCH=$(echo ${{ github.ref_name }} | sed 's/\//-/g' | tr '[:upper:]' '[:lower:]')
            IMAGE_TAG="${BRANCH}-${SHORT_SHA}"
            echo "âš ï¸  build job è¼¸å‡ºç‚ºç©ºï¼Œä½¿ç”¨ç”Ÿæˆçš„æ¨™ç±¤: $IMAGE_TAG"
          fi
          
          # è¨­ç½®è¼¸å‡º
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "full_image=${{ env.REGISTRY_URL }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          # é©—è­‰æ˜ åƒæ˜¯å¦å­˜åœ¨
          echo "é©—è­‰æ˜ åƒæ˜¯å¦å­˜åœ¨..."
          if docker manifest inspect ${{ env.REGISTRY_URL }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG >/dev/null 2>&1; then
            echo "âœ… æ˜ åƒå·²ç¢ºèªå­˜åœ¨"
          else
            echo "âŒ è­¦å‘Š: æ˜ åƒå¯èƒ½ä¸å­˜åœ¨ï¼Œéƒ¨ç½²å¯èƒ½æœƒå¤±æ•—"
            echo "æ˜ åƒè·¯å¾‘: ${{ env.REGISTRY_URL }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG"
          fi

      - name: éƒ¨ç½² Helm Chart
        run: |
          echo "é–‹å§‹éƒ¨ç½² Helm Chart..."
          echo "ä½¿ç”¨æ˜ åƒ: ${{ steps.prepare-tag.outputs.full_image }}"
          echo "æ˜ åƒæ¨™ç±¤: ${{ steps.prepare-tag.outputs.tag }}"
          
          # ä½¿ç”¨æº–å‚™å¥½çš„æ˜ åƒæ¨™ç±¤é€²è¡Œéƒ¨ç½² (Secret Manager å¤–æ›ç¨‹å¼)
          helm upgrade --install ${{ env.DEPLOYMENT_NAME }} ./Helm \
            --namespace ${{ env.DEPLOYMENT_NAME }} \
            --set image.repository=${{ env.REGISTRY_URL }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ steps.prepare-tag.outputs.tag }} \
            --set imagePullSecrets[0].name=ghcr-auth \
            --set gcp.projectId=${{ env.PROJECT_ID }} \
            --create-namespace \
            --wait --timeout=10m \
            --atomic \
            --debug

      - name: é©—è­‰é—œéµè³‡æº
        run: |
          echo "ğŸ“‹ é©—è­‰éƒ¨ç½²çš„é—œéµè³‡æº..."
          
          echo "=== ServiceAccount ç‹€æ…‹ ==="
          if kubectl get serviceaccount ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }} >/dev/null 2>&1; then
            echo "âœ… ServiceAccount å·²å‰µå»º"
            kubectl get serviceaccount ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }}
          else
            echo "âŒ ServiceAccount ä¸å­˜åœ¨ï¼Œé€™æœƒå°è‡´ Pod ç„¡æ³•å•Ÿå‹•"
            echo "åˆ—å‡ºæ‰€æœ‰ ServiceAccountï¼š"
            kubectl get serviceaccount -n ${{ env.DEPLOYMENT_NAME }}
          fi
          
          echo "=== ConfigMap ç‹€æ…‹ ==="
          kubectl get configmap -n ${{ env.DEPLOYMENT_NAME }} || echo "ç„¡ ConfigMap"
          
          echo "=== Secret ç‹€æ…‹ ==="
          kubectl get secret -n ${{ env.DEPLOYMENT_NAME }}
          
          echo "=== æª¢æŸ¥æ‡‰ç”¨ Secret æ˜¯å¦å­˜åœ¨ ==="
          if kubectl get secret ${{ env.DEPLOYMENT_NAME }}-app-secret -n ${{ env.DEPLOYMENT_NAME }} >/dev/null 2>&1; then
            echo "âœ… æ‡‰ç”¨ Secret å­˜åœ¨"
            kubectl describe secret ${{ env.DEPLOYMENT_NAME }}-app-secret -n ${{ env.DEPLOYMENT_NAME }}
          else
            echo "âŒ æ‡‰ç”¨ Secret ä¸å­˜åœ¨ - é€™æœƒå°è‡´ç’°å¢ƒè®Šæ•¸ç„¡æ³•è¼‰å…¥"
          fi
          
          echo "=== ç«‹å³æª¢æŸ¥ Pod å‰µå»º ==="
          sleep 5
          kubectl get pods -n ${{ env.DEPLOYMENT_NAME }} -o wide
          
          # å¦‚æœæ²’æœ‰ Podï¼Œæª¢æŸ¥ ReplicaSet
          POD_COUNT=$(kubectl get pods -n ${{ env.DEPLOYMENT_NAME }} --no-headers | wc -l)
          if [[ $POD_COUNT -eq 0 ]]; then
            echo "âš ï¸  æ²’æœ‰ Pod è¢«å‰µå»ºï¼Œæª¢æŸ¥ ReplicaSet..."
            kubectl get replicaset -n ${{ env.DEPLOYMENT_NAME }}
            kubectl describe replicaset -n ${{ env.DEPLOYMENT_NAME }}
          fi

      - name: è¨ºæ–· Pod å•Ÿå‹•å•é¡Œ
        run: |
          echo "ğŸ” è¨ºæ–· Pod ç‚ºä»€éº¼ç„¡æ³•å•Ÿå‹•..."
          
          echo "=== Deployment ç‹€æ…‹ ==="
          kubectl get deployment ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }} -o wide
          kubectl describe deployment ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }}
          
          echo "=== ReplicaSet ç‹€æ…‹ ==="
          kubectl get replicaset -n ${{ env.DEPLOYMENT_NAME }}
          kubectl describe replicaset -n ${{ env.DEPLOYMENT_NAME }}
          
          echo "=== Pod ç‹€æ…‹å’Œè©³ç´°è³‡è¨Š ==="
          kubectl get pods -n ${{ env.DEPLOYMENT_NAME }} -o wide
          
          # ç²å–æ‰€æœ‰ Pod ä¸¦é€ä¸€è¨ºæ–·
          PODS=$(kubectl get pods -n ${{ env.DEPLOYMENT_NAME }} -o jsonpath='{.items[*].metadata.name}')
          for pod in $PODS; do
            echo "--- è¨ºæ–· Pod: $pod ---"
            kubectl describe pod $pod -n ${{ env.DEPLOYMENT_NAME }}
            
            echo "--- Pod ç’°å¢ƒè®Šæ•¸æª¢æŸ¥: $pod ---"
            if kubectl exec $pod -n ${{ env.DEPLOYMENT_NAME }} -- printenv | grep -E "(JWT_SECRET|DB_PASS|DB_USER)" 2>/dev/null; then
              echo "âœ… æ‰¾åˆ°æ‰€éœ€ç’°å¢ƒè®Šæ•¸"
            else
              echo "âŒ Pod ä¸­ç¼ºå°‘æ‰€éœ€ç’°å¢ƒè®Šæ•¸"
              echo "æ‰€æœ‰ç’°å¢ƒè®Šæ•¸ï¼š"
              kubectl exec $pod -n ${{ env.DEPLOYMENT_NAME }} -- printenv 2>/dev/null | head -10 || echo "ç„¡æ³•åŸ·è¡Œç’°å¢ƒè®Šæ•¸æª¢æŸ¥"
            fi
            
            echo "--- Pod æ—¥èªŒ: $pod ---"
            kubectl logs $pod -n ${{ env.DEPLOYMENT_NAME }} || echo "ç„¡æ³•ç²å–æ—¥èªŒ"
          done
          
          echo "=== æª¢æŸ¥ ServiceAccount ==="
          kubectl get serviceaccount -n ${{ env.DEPLOYMENT_NAME }}
          kubectl describe serviceaccount ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }} || echo "ServiceAccount ä¸å­˜åœ¨"
          
          echo "=== æª¢æŸ¥ Secrets ==="
          kubectl get secrets -n ${{ env.DEPLOYMENT_NAME }}
          
          echo "=== æª¢æŸ¥ç¯€é»è³‡æº ==="
          kubectl describe nodes | grep -E "(Name:|cpu|memory|Allocated|allocatable)" || echo "ç„¡æ³•ç²å–ç¯€é»è³‡æºè³‡è¨Š"

      - name: é©—è­‰éƒ¨ç½²ç‹€æ…‹
        run: |
          echo "é©—è­‰éƒ¨ç½²ç‹€æ…‹..."
          kubectl get pods -n ${{ env.DEPLOYMENT_NAME }}
          kubectl get services -n ${{ env.DEPLOYMENT_NAME }}
          kubectl get ingress -n ${{ env.DEPLOYMENT_NAME }} || echo "ç„¡ Ingress è³‡æº"
          
          # æª¢æŸ¥ Pod å°±ç·’ç‹€æ…‹
          echo "ç­‰å¾… Pod å°±ç·’..."
          kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=deno-web-app \
            -n ${{ env.DEPLOYMENT_NAME }} --timeout=300s || echo "æŸäº› Pod å¯èƒ½é‚„æœªå°±ç·’"
          
          echo "âœ… éƒ¨ç½²å®Œæˆ"

      - name: æ•…éšœæ’é™¤è³‡è¨Š
        if: failure()
        run: |
          echo "ğŸš¨ éƒ¨ç½²å¤±æ•—ï¼Œæ”¶é›†è¨ºæ–·è³‡è¨Š..."
          
          echo "=== Helm Release ç‹€æ…‹ ==="
          helm list -n ${{ env.DEPLOYMENT_NAME }} -a || echo "ç„¡æ³•ç²å– Helm release åˆ—è¡¨"
          helm status ${{ env.DEPLOYMENT_NAME }} -n ${{ env.DEPLOYMENT_NAME }} || echo "ç„¡æ³•ç²å– release ç‹€æ…‹"
          
          echo "=== Kubernetes äº‹ä»¶ ==="
          kubectl get events -n ${{ env.DEPLOYMENT_NAME }} --sort-by='.lastTimestamp' --field-selector type!=Normal || echo "ç„¡æ³•ç²å–äº‹ä»¶"
          
          echo "=== Pod è©³ç´°è³‡è¨Š ==="
          kubectl describe pods -n ${{ env.DEPLOYMENT_NAME }} || echo "ç„¡æ³•ç²å– Pod æè¿°"
          
          echo "=== Pod æ—¥èªŒ ==="
          for pod in $(kubectl get pods -n ${{ env.DEPLOYMENT_NAME }} -o name); do
            echo "--- $pod æ—¥èªŒ ---"
            kubectl logs $pod -n ${{ env.DEPLOYMENT_NAME }} --tail=50 || echo "ç„¡æ³•ç²å–æ—¥èªŒ"
          done